source：[https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java 并发.md)

# 一、使用线程

有三种使用线程的方法

* 实现Runnable接口
* 实现Callable接口
* 继承Thread类

实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此还需要通过Thread来调用。可以理解为任务是通过线程驱动从而执行的。

## 实现Runnable接口

需要实现接口中的 run() 方法。

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // ...
    }
}
```

```java
public static void main(String[] args){
	new Thread(new MyRunnable()).start();
}
```

使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。

## 实现Callable

与Runnable相比，Callable可以有返回值，返回值通过FutureTask进行封装。

```java
public class MyCallable implements Callable<Integer> {
	public Integer call(){
		return 123;
	}
}
```

```java
public static void main(String[] args) throws ExecutionException, InterruptedException{
	MyCallable mc = new MyCallable();
	FutureTask<Integer> ft = new FutureTask<>(mc);
	Thread thread = new Thread(ft);
	thread.start();
	System.out.println(ft.get());
}
```

## 继承Thread类

同样也是需要实现run()方法，因为Thread类也实现了Runnable接口。
当调用start()方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的run()方法。

```java
public class MyThread extends Thread{
	public void run(){
		//...
	}
}
```

```java
public static void main(String[] args){
	MyThread mt = new MyThread();
	mt.start();
}
```

## 实现接口VS继承Thread

实现接口会更好一些；因为：

* Java不支持多重继承，因此继承了Thread类就无法继承其它类，但是可以实现多个接口；
* 类可能只要求执行就行，继承整个Thread类开销过大。

# 二、基础线程机制

## Executor

Executor管理多个异步任务的执行，而无需程序员显式地管理线程的声明周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种Executor：

* CachedThreadPool:一个任务创建一个线程；
* FixedThreadPool:所有任务只能使用固定大小的线程；
* SingleThreadExecutor:相当于大小为1的FixedThreadPool。

```java
public static void main(String[] args){
	ExecutorService executorService = Executor.newCachedThreadPool();
	for(int i=0; i<5; i++){
		executorService.execute(new MyRunnable());
	}
	executorService.shutdown();
}
```

## Daemon

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。
当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。
main()属于非守护线程。
在线程启动之前使用setDaemon()方法可以将一个线程设置为守护线程。

```java
public static void main（String[] args){
	Thread thread = new Thread(new MyRunnable());
	thread.setDaemon(true);
}
```

## sleep()

Thread.sleep(millisec)方法会休眠当前正在执行的线程，millsec单位为毫秒。
sleep()可能会抛出InterruptedException，因为异常不能跨线程传播回main()中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```java
public void run(){
	try{
		Thread.sleep(3000);
	}catch(InterruptedException e){
		e.printStackTrace();
	}
}
```

## yield()

对静态方法Thread.yield()的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```java
public void run(){
	Thread.yeild();
}
```

# 三、中断

一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。

## InterruptedException

通过调用一个线程的interrupt()来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出InterruptedException，从而提前结束该线程。但是不能中断I/O阻塞和synchronized锁阻塞。
对于以下代码，在main()中启动一个线程之后再中断它，由于线程中调用了Thread.sleep()方法，因此会抛出一个InterruptedException，从而提前结束线程，不执行之后的语句。

```java
public class InterruptExample{
	private static class MyThread1 extends Thread{
		@Override
		public void run(){
			try{
				Thread.sleep(2000);
				System.out.println("Thread run");
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
}
```

```java
public static void main(String[] args) throws InterruptedException{
	Thread thread1 = new MyThread1();
	thread1.start;
	thread1.interrupt();
	System.out.println("Main run");
}
```

```java
Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at InterruptExample.lambda$main$0(InterruptExample.java:5)
    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:745)
```

## interrupted()

如果一个线程的run()方法执行一个无线循环，并且没有执行sleep()等会抛出InterruptedException的操作，那么调用线程的interrupt()方法就无法使线程提前结束。
但是调用interrupt()方法会设置线程的中断标记，此时调用interrupted()方法会返回true。因此可以在循环体中使用interrupted()方法来判断线程是否处于中断状态，从而提前结束线程。

```java
public class InterruptExample{
	private static class MyThread2 extends Thread{
		@Overried
		public void run(){
			while(!interrupted()){
				// ...
			}
			System.out.println("Thread end");
		}
	}
}
```

```java
public static void main(String[] args){
	Thread thread2 = new Thread2();
	thread2.start();
	thread2.interrupt();
}
```

```
Thread end
```

## Executor的中断操作

调用Executor的shutdown()方法会等待线程都执行完毕之后再关闭，但是如果调用的是shutdownNow()方法，则相当于调用每个线程的interrupt()方法。
以下使用Lambada创建线程，相当于创建了一个匿名内部线程。

```java
public static void main(String[] args){
	ExecutorService executorService = Executors.newCachedThreadPool();
	executorService.execute(() -> {
		try{
            Thread.sleep(2000);
            System.out.println("Thread run");
		}catch(InterruptedException e){
			e.printStackTrace();
		}
	});
	executorService.shutdownNow();
	System.out.println("Main run");
}
```

```java
Main run
java.lang.InterruptedException: sleep interrupted
    at java.lang.Thread.sleep(Native Method)
    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)
    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

如果只想中断Executor中的一个线程，可以通过使用submit()方法来提交一个线程，它会返回一个Future<?>对象，通过调用该对象的cancel(true)方法就可以中断线程。

```java
Future<?> future = executorService.sumit(() -> {
	//...
})
future.cancel(true);
```

# 四、互斥同步

Java提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是JVM实现的synchronzied，而另一个是JDK实现的ReentrantLock。

## synchronized

### 1.同步一个代码块

```java
public void func(){
	synchronized(this){
		//...
	}
}
```

它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
对于一下代码，使用synchronized执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。

```java
public class SynchronizedExample{
	public void func1(){
		synchronized(this){
			for(int i=0; i<10; i++){
				System.out.print(i + " ");
			}
		}
	}
}
```

```java
public static void main(String[] args){
	SychronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func1());
    executorService.execute(() -> e1.func1());
}
```

```java
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。

```java
public static void main(String[] args){
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService excutorService = Executors.newCachedThreadPool();
    executorService.execute(() -> e1.func1());
    executorService.execute(() -> e2.func2());
}
```

```
0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
```

### 2.同步一个方法

```java
public synchronized void func(){
    //...
}
```

它和同步代码块一样，作用于同一个对象

### 3.同步一个类

```java
public void func(){
    synchronized(SynchronizedExample.class){
        //...
    }
}
```

作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。

```java
public class SynchronizedExample{
    public void func2(){
        synchronized(SynchronizedExample.class){
            for(int i=0; i<10; i++){
                System.out.print(i + " ");
            }
        }
    }
}
```

```java
public static void main(String[] args){
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExcutorService excutorService = Excutors.newCachedTreadPool();
    excutorService.excute(() -> e1.func2());
    excutorService.excutr(() -> e2.func2());
}
```

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

### 4.同步一个静态方法

```java
public synchronized static void fun(){
    //...
}
```

作用于整个类。

## ReentrantLock

ReentrantLock是java.util.concurrent(J.U.C)包中的锁。

```java
public class LockExample{
    
    private Lock lock = new ReentrantLock();
    
    public void func(){
        lock.lock();
        try{
            for(int i=0; i<10; i++){
                System.out.print(i + " ");
            }
        }finally{
           lock.unlock();//确保释放锁，从而避免发生死锁。 
        }
    }
}
```

```java
public static void main(String[] args){
    LockExample lockExample = new LockExample();
    ExcutorService excutorService = Excutors.newCachedTreadPool();
    excutorService.excute(() -> lockExample.func());
    excutorService.excute(() -> lockExample.func());
}
```

```
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```

## 比较

### 1.锁的实现

synchronized 是JVM实现的，而ReentrantLock是JDK实现的。

### 2.性能

新版本Java对synchronized进行了很多优化，例如自旋锁等，synchronized与ReentrantLock大致相同。

### 3.等待可中断

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

### 4.公平锁

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但是也可以是公平的。

### 5.锁绑定多个条件

一个ReentrantLock可以同时绑定多个Condition对象。

## 使用选择

除非需要使用ReentrantLock的高级功能，否则有限使用synchronized。这是因为synchronized是JVM实现的一种锁机制，JVM原生地支持它，而ReentrantLock不是所有JDK版本都支持。并且使用synchronized不用担心没有释放锁而导致死锁问题，因为JVM会确保锁的释放。

# 五、线程之间的协作

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么久需要对线程进行协调。

## join()

在线程中调用另一个线程的join()方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

对于以下代码，虽然b线程先启动，但是因为在b线程中调用了a线程的join()方法，b线程会等待a线程结束才继续执行，因此最后能够保证a线程的输出先于b线程的输出。

```java
public class JoinExample{
    
    private class A extends Thread{
        @Override
        public void run(){
            System.out.println("A");
        }
    }
    
    private class B extends Thread{
        private A a;
        B(A a) {
            this.a = a;
        }
        
        @Override
        public void run(){
            try{
                a.join();
            }catch(InterruptedException e){
                e.printStackTrace();
            }
            System.out.println("B");
        }
    }
    
    public void test(){
        A a = new A();
        B b = new B();
        b.start();
        a.start();
    }
}
```

```java
public static void main(String[] args){
    JoinExample example = new JoinExample();
    example.test();
}
```

```
A
B
```

## wait() notify() notifyAll()

调用wait()使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用notify()或者notifyAll()来唤醒挂起的线程。

它们都属于Object()的一部分，而不属于Thread。

只能用在同步方法或者同步控制块中使用，否则会在运行时抛出IllegalMonitorStateException。

使用wait()挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行notify()或者notifyAll()来唤醒挂起的线程，造成死锁。

```java
public class WaitNotifyExample{
    
    public synchronized void before(){
        System.out.println("before");
        notifyAll();
    }
    
    public synchronized void after(){
        try{
            wait();
        }catch(InterruptedException e){
            e.printStackTrace();
        }
        System.out.println("after");
    }
    
}
```

```java
public static void main(String[] args){
    WaitNotifyExample example = new WaitNotifyExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> example.after());
    executorService.executr(() -> example.before());
}
```

```
before
after
```

### wait() 和sleep() 区别

* wait() 是Object的方法，而sleep是Thread的静态方法；
* wait()会释放锁，sleep()不会。

## await() signal() signalAll()

java.util.concurrent类库中提供了Condition类来实现线程之间的协调，可以在Condition上调用await()方法使线程等待，其它线程调用signal()或者signalAll()方法唤醒等待的线程。

相比于wait()这种等待方式，await()可以指定等待的条件，因此更加灵活。

```java
public class AwaitSignalExample{
    
    private Lock lock = new ReentrantLock();
    pricate Condition condition = lock.newCondition();
    
    public void before(){
        lock.lock();
        try{
            System.out.println("before");
            condition.signalAll();
        }finally{
            lock.unlock();
        }
    }
    
    public void after(){
        lock.lock();
        try{
            condition.await();
            System.out.println("after");
        }catch(InterruptedException e){
            e.printStackTrace();
        }finally{
            lock.unlock();
        }  
    }
}
```

```java
public static void main(String[] args){
    AwaitSignalExample example = new AwaitSignalExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -> example.after());
    executorService.execute(() -> example.before());
}
```

```
before
after
```

# 六、线程状态

一个线程只能处于一种状态，并且这里的线程状态特指Java虚拟机的线程状态，不能反映线程在特定操作系统下的状态。

## 新建(NEW)

创建后尚未启动

## 可运行(RUNNABLE)

正在Java虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统额资源调度。

## 阻塞(BLOCKED)

请求获取monitor lock，从而进入synchronized函数或者代码块，但是其它线程已经占用该monitor lock，所以出于阻塞状态。要结束该状态进入，从而RUNNABLE需要其它线程释放monitor lock。

## 无限期等待(WAITING)

等待其它线程显式地唤醒。

阻塞和等待的区别在于，阻塞是被动，它是在等待获取monitor lock。而等待是主动的，通过调用Object.wait()等方法进入。

| 进入方法                                   | 退出方法                             |
| ------------------------------------------ | ------------------------------------ |
| 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
| 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
| LockSupport.park() 方法                    | LockSupport.unpark(Thread)           |

## 限期等待(TIMED_WAITING)

无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

| 进入方法                                 | 退出方法                                        |
| ---------------------------------------- | ----------------------------------------------- |
| Thread.sleep() 方法                      | 时间结束                                        |
| 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
| 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕                 |
| LockSupport.parkNanos() 方法             | LockSupport.unpark(Thread)                      |
| LockSupport.parkUntil() 方法             | LockSupport.unpark(Thread)                      |

调用Thread.sleep()方法使线程进入限期等待状态是，常常用“使一个线程睡眠”进行描述。调用Object.wait()方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

## 死亡(TERMINATED)

可以是线程结束任务之后自己结束，或者产生了异常而结束。

[Java SE 9 Enum Thread.State](https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html)

# 七、J.U.C - AQS

java.util.concurrent(J.U.C)大大提高了并发性能，AQS被认为是J.U.C的核心。

## CountDownLatch

用来控制一个或者多个线程等待多个线程。

维护了一个计数器cnt，每次调用countDown()方法会让计数器的值减1，减到0的时候，那些因为调用await()方法而在等待的线程就会被唤醒。

![img](https://camo.githubusercontent.com/c2a94b75d7379c204996f24411a9c497125cfa06/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62613037383239312d373931652d343337382d623664312d6563653736633266306231342e706e67)

```java
public class CountdownLatchExample{
    
    public staic void main(String[] args) throws InterruptedException{
        final int totalThread = 10;
        CountDownLath countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for(int i=0; i<totalThread; i++){
            executorService.execute(() -> {
               System.out.print("run...");
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        System.out.print("end");
        executorService.shutdown();
    }
}
```
```
run..run..run..run..run..run..run..run..run..run..end
```
## CyclicBarrier
用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。
和CountDownLatch相似，都是通过维护计数器来实现的。线程执行await()方法之后计数器会减1，并进行等待，直到计数器为0，所有调用await()方法而在等待的线程才能继续执行。
CyclicBarrier和CountDownLatch的一个区别是，CyclicBarrier的计数器通过调用reset()方法可以循环使用，所以它才叫做循环屏障。
CyclicBarrier有两个构造函数，其中parties指示计数器的初始值，barrierAction在所有线程都到达屏障的时候会执行一次。
```java
public CyclicBarrier(int parties, Runnable barrierAction){
	if(parties <= 0) throw new IllegalArgumentException;
	this.parties = parties;
	this.count = parties;
	this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties){
	this(parties, null);
}
```