多想想 如果是你 设计一个表结构来支持 并发你会如何做
然后 从这个思路去回答


为何linux2.0 引入 smp的时候用了BKL 而不用 自旋锁 mutex 信号量  seq 读写锁等
任何 技术需要一个过渡阶段 Myisam 就是这样的引擎 而 Innodb的出现就打散了 锁分布

粗锁 细锁 伪无锁  无锁
锁资源而不是代码
而 竞争代码在哪
无锁就是线程绑定

去学习下 内核吧  把里面的思想学了，  就不会有这么多疑惑了
Netty的 内存管理  Jemalloc  内核 内存管理 都是一样的思想
只不过 内核自己来了一套应用层来了一套
C库自己一个
JVM自己一个
全是 互相抄 思想一模一样
多思考 多想如果是你你会怎么设计
别被应试教育 压制思想太长时间

JVM 的书 你就不要让我推荐了
看源码
先走一遍 启动流程
跳过 初始化
学下 pthread的 操作
两个重点：1、pthread 的 线程 管理  2、互斥操作
然后走一遍 宏观
然后针对于  某一点继续看
比如 OOP-CLASS  Universe
GC interface
Runtime
Service
VMthread
JVMT1
找一个点看即可

你们想想   为何我们需要GC移动对象
根本不需要
移动对象是因为 碎片
那么问题来了 HOTSPOT的对象 基础大小是多少？
8byte
碎片大小 是不是8byte
8字节对齐
那么问题来了 我打散  多个8byte
让  对象在 虚拟地址空间连续
然后建立页表
映射到 不同的8
这不就是OS的 内存管理机制么
这是模拟 计算机底层 做 虚拟空间--物理空间？
这样我垃圾回收我只需要把页表置位即可
相当于你中间加了一个管理碎片化
2 64 位地址空间
直接建立一个top指针
CAS 分配即可
然后从 叶框的 bitmap上 寻找分配即可
释放如何释放
直接置位0 即可
不需要 额外的 移动操作
黄老师那页表内部会产生内碎片吧？
表 存在 碎片 啥意思
你建立一个 hashmap 你会管key的碎片？
页表的维护 会不会带来新的问题 。。。 以前移动有消耗，但是稳定啊
黄师傅我刚刚的意思是释放对象的时候 还是会在内存页内形成碎片 不会啊
你不用担心有问题
那为何OS没问题
OS 做的可比 JVM大多了
况且现在又专门 做JVM的 硬件
直接把JVM 跑在硬件上
移动的消耗  大多了

黄老邪 我记得你以前讲课提到过  内存分配 操作系统将内存分成大大小小不同的大小，然后需要用多大的就去分配 里面好像有些专业名词 叫什么来着。伙伴什么的
伙伴分配+slab
就是 netty的
area 和 poolchunk
对比netty 记吧
一模一样的


所谓的ZGC 你们认为  真的解决了问题了么

内核的maxorder默认11
4kb一页
你算算多少M
netty也是抄的os的这套 。。。
准确的说是抄 Jemalloc
jemalloc 是C的

去看看 OS的 分页机制吧
我这里 就是容忍碎片
内存页占不满 就占不满，占了的（不管占了多少，后面分配不给这个页分配就好了），就是浪费了点
你碎你的 随便来
每页都是满的
4kb一页
一页分成8byte
总共  512  个 8byte
碎片整理 直接 伙伴分配器即可
然后对 每个线程内部维护一个slab
slab负责切割管理  8byte

对于slab的思想 学了 具体 可看netty的 subpagepool

spring 的基础框架 ： BPP BFPP 事件机制
beanpostprocesser  beanfactorypostprocesser 

linux内核学习路线：通用操作系统概念->linux内核设计与实现->源码+深入理解linux内核

然后 最重要的是KPA
KPI + PPT +API
Rust还是可以学学的
