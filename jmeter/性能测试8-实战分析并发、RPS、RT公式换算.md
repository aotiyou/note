### 实战分析并发、RPS、RT 公式换算

## 前提

**并发数 = RPS \* 响应时间**

### 第一次实验

**100线程，一次迭代，启动时间1s，线程组和聚合报告如图所示**

从结果可以看出，100并发/s，一次迭代，平均响应时间是68ms
如果根据上面公式来看的话
RPS = 并发数/响应时间 = 100/0.068 ，大约是1470/S
但是我们在线程组中可以看出，预置的RPS是 100/S
差距有点大哦~~~眉头紧锁，思考中

### 第二次实验

**100线程，持续迭代，1s内启动线程，持续运行10s。线程组和聚合报告如图所示。**

从聚合报告可以看出来，平均TPS= 1303。那么我们可不可以就认定这个TPS=RPS呢？
简单计算一下就知道了。
图中可以看出我们的平均响应时间是72ms，那么1秒内大约能迭代14次。100个线程下，一秒内大约能发送1400个请求。
因此我们的RPS大约是1400/S
这样就能看出来，一秒内发送1400次请求，但是1s内只有1300个请求能响应完毕
我们再反向验证一下并发数
并发数 = RPS*响应时间，1400* 0.072 等于100.8，和线程组里面设置的并发数几乎相同。
如果我们用Throughput=RPS去反向验证
并发数 = RPS*响应时间，1303* 0.072 等于93，和线程组里面设置的并发数就有一些差距了。
这两次实验得出的结论：在持续迭代下，由于样本充足，所以公式成立。但是**RPS！= TPS**

### 第三次实验

**这次我们直接加上RPS定时器，通过精准的RPS来验证公式
我们让200RPS保持1分钟，查看聚合报告**

首先我们就能看出，在200RPS下，平均TPS只有172！
其次，平均并发数 = 200*0.047 = 9.4  意味着我只需要9个线程，就可以在一秒内释放200RPS的压力
可以算出每个线程每秒的请求数是 200/9.4 =21，也就是一个线程一秒内最大迭代21次
反推每个请求的响应时间 大约 是 1000/21 大约是 47ms 
前后验证的结果都相符！

### 第四次实验

**这一次我们直接在线程组中设置刚刚20RPS下得出的平均并发数值 9，反向推断出RPS的准确性**

计算一下RPS = 9 /0.043 约等于209
 因为线程组只能设置整数，所以会和实验三有一些误差，不影响测试的准确性
 **结尾语：从几次实验结果来看，在样本充足的情况下，公式是没有问题的**